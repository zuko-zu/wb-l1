<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
  </head>
  <body>
    <script>
      // инициализируем переменную для хранения количества рекурсивных вызовов
      let callSize = 0;

      function executeRecursion() {
        // Увеличиваем счетчик вызовов на 1
        callSize++;
        // Вызваем функцию повторно
        document.write('<script>executeRecursion();<\/script>');
      }

      // Вызываем рекурсию
      executeRecursion();
      // Выводим количество рекурсивных вызовов и вычитаем 1 инициализирующий вызов
      console.log(callSize - 1);

      // Есть отличная статья, описывающая все тонкости document.write(), которая помогла с решением этой задачи
      // https://habr.com/ru/articles/305366/

      // Изначально казался логичным ответ, что функция будет вызываться столько раз, сколько позволить размер коллстека,
      // что и происходит при обычном рекурсивном вызове через циклы.
      // Однако поведение браузера меняется, если document write добавляет script с рекурсивным вызовом.
      // Результат соответсвует тому, что описано в статье.
      // В среднем это число 20, в хроме 21.

      // Ключевая разница заключается в том, что такой код хоть и рекурсивный,
      // но он НЕ ВЫЗЫВАЕТ ПЕРЕПОЛНЕНИЯ СТЕКА ВЫЗОВОВ, вызовы просто не попадают в коллстек.
      // (Поэтоу мы не можем получить ошибку "stack overflow")
      // Эти вызовы просто добавялются к текущей странице и выполняются после завершения основного кода.
      // Такие случаи нужно было как-то обрабатывать, и поэтому разработчики приняли решение
      // поставить ограничения, чтобы исключить потенциальную возможность уронить браузер.
    </script>
  </body>
</html>
